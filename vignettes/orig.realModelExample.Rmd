---
title: "Deconvolution of murine lymph node samples"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    vignette: >
      %\VignetteIndexEntry{Deconvolution of murine lymph node samples}
      %\VignetteEngine{knitr::rmarkdown}
      %\VignetteEncoding{UTF-8}
bibliography: references.bib
geometry: margin=3cm
fontsize: 12pt
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, dpi = 80,
  base.dir = ".", fig.path = "", fig.align = "center"
)
```

<!-- Reference: @Li2017 -->

In this vignette, we are going to be analyzing a spatial transcriptomics dataset (10x Visium)  which consists of three murine lymph nodes, two of them after 48-hour stimulation by _Mycobacterium smegmatis_, from @Lopez2022. As reference, we will use the paired single-cell RNA-seq (10x Chromium) from the same study. Raw data can be found on [GEO](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE173778), but for simplicity, we have make them available through the [SpatialDDLSdata](https://github.com/diegommcc/SpatialDDLSdata) R data package.

# Loading data

Firstly, let's load the required packages and data:

```{r}
library("SpatialDDLS")
library("SingleCellExperiment")
library("SpatialExperiment")
library("ggplot2")
library("ggpubr")

## in case it is not installed
if (!requireNamespace("SpatialDDLS", quietly = TRUE)) {
  if (!requireNamespace("devtools", quietly = TRUE)) {
    install.packages("devtools")
  }
  devtools::install_github("diegommcc/SpatialDDLSdata")
}
library("SpatialDDLSdata")
data(MouseDLN.SCE)
data(MouseDLN.ST)
```


## Loading data into a `SpatialDDLS` object

Now, we have to create a `SpatialDDLS` object. This class will be the core in which all the steps until the deconvolution of every spot will be done. We recommend providing both, the spatial and single-cell transcriptomics data, in order to filter and select only those genes that are present in both types of data for further processing. 

```{r}
mouseDLN.SDDLS <- createSpatialDDLSobject(
  sc.data = MouseDLN.SCE, 
  sc.cell.ID.column = "CellID", 
  sc.gene.ID.column = "GeneSymbol",
  sc.cell.type.column = "broad_cell_types",
  st.data = MouseDLN.ST,
  sc.filt.genes.cells = TRUE,
  sc.min.counts = 1, 
  sc.min.cells = 3,
  sc.filt.genes.cluster = TRUE,
  sc.min.mean.counts = 3,
  sc.min.counts = 4, 
  sc.min.cells = 3,
  st.spot.ID.column = "CellID",
  st.gene.ID.column = "GeneSymbol"
)
```

We can show some basic information about the object: 

```{r}
mouseDLN.SDDLS
```


## Simulation of mixed transcriptional profiles

Now, we are going to simulate the cell composition matrices that will serve to simulate mixed transcriptional profiles with known cell proportions. This is done by the `genMixSpotProp` function in which we can control different aspects such as the number of mixed transcriptional profiles that will be generated, the number of cells used for each mixed profile, etc. These parameters must be decided depending on the reference used and the available computational resources. For this example, and as standard reference, we will use ` = 10000` and ` = 200`. For more information about these parameters and others, see the Documentation. These cell type proportions will be generated by three methods: 

* A random sampling of a Dirichlet distribution. Moreover, in order to make these proportions more sparse, the `prob.sparity` parameter controls the probability of having missing cell types in each simulated spot, as opposed to a mixture of all cell types. 
* Pure mixed transcriptional profiles composed of `n.cells` cells of the same cell type aggregated.
* Transcriptional profiles in which a minimum number of missing cell types will be imposed. This is control by the `min.zero.prop` argument. 

The relative abundance of samples generated by these criteria can be control by the `proportion.method` parameter. Finally,`genMixSpotProp` will automatically divide the reference cells contained in the `single.cell.real` slot into training and test subsets and randomly assign `` cells to make up every mixed transcriptional profile. 

```{r}
mouseDLN.SDDLS <- genMixedCellProp(
  mouseDLN.SDDLS,
  cell.ID.column = "CellID",
  cell.type.column = "broad_cell_types",
  num.sim.spots = 15000,
  n.cells = 200,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  proportion.method = c(0.6, 0.2, 0.2),
  prob.sparity = 0.5, 
  min.zero.prop = 9,
  balanced.type.cells = TRUE,
  verbose = TRUE
)
```


Then, we can call the `simMixedProfiles` function which will generate the actual mixed transcriptional profiles using the cell composition matrices generated in the previous step. This step may take a while depending on the number of transcriptional profiles to be simulated, so be patient! In addition, the way the mixed profiles will be generated can be decided. We recommend summing up raw counts, and then normalize samples by log-CPM (`mixing.function = "AddRawCount"`), but other methods are available (see Documentation). 

```{r}
mouseDLN.SDDLS <- simMixedProfiles(mouseDLN.SDDLS, threads = 3)
```

## Training a fully-connected neural network using mixed transcriptional profiles

Once we have generated a bunch of mixed transcriptional profiles with a known cell composition, we can train a neural network with our train subset to make it predict the cell type proportions present in the test subset. After training, this model will be capable of making cell type proportion predictions uniquely based on the transcriptional profile of new samples, i.e., each spot in a spatial transcriptomics experiment. The architecture of the network is fully customizable and should be changed depending on the number of genes used as input and the complexity of the biological context that is being studied. In this case, we will use a model with 3 hidden layers, each with 200 neurons, and a training process with a total of 40 epochs. 

```{r}
mouseDLN.SDDLS <- trainDeconvModel(
  mouseDLN.SDDLS,
  num.epochs = 40, 
  activation.fun = "relu",
  num.hidden.layers = 3, 
  num.units = c(200, 200, 200), 
) 
```

By default, some metrics about the performance of the model will be displayed. In the end, we can calculate more elaborated metrics using the `calculateEvalMetrics` function. It will calculate MAE and MSE per cell type, so that it may give us a hint about what performance the model is having for each cell type. These metrics can be visualized using different functions: 

```{r}
mouseDLN.SDDLS <- calculateEvalMetrics(mouseDLN.SDDLS)
distErrorPlot(
  mouseDLN.SDDLS,
  error = "AbsErr",
  x.by = "CellType",
  color.by = "CellType", 
  error.labels = FALSE, 
  type = "boxplot",
  size.point = 0.5
)
```


```{r}
barErrorPlot(mouseDLN.SDDLS, error = "MAE", by = "CellType")
```


```{r}
distErrorPlot(
  mouseDLN.SDDLS,
  x.by = "pBin",
  error = "AbsErr",
  facet.by = "CellType",
  color.by = "CellType", 
  error.label = TRUE,
  type = "boxplot"
)
```


```{r}
corrExpPredPlot(
  mouseDLN.SDDLS,
  color.by = "CellType",
  facet.by = "CellType",
  corr = "both", 
  size.point = 0.5
)
```

As it can be seen, the overall performance is good, which means that the model is being able to understand what characterizes each cell type to make accurate predictions about the cell type composition of the samples. 

## Deconvolution of the spatial transcriptomics dataset

Finally, we can use our recently trained model to deconvolute the signals of each spot! This step is very quick. As we already loaded the spatial transcriptomics experiment we wanted to deconvolut, calling the `deconvSpatialDDLS` function is enough, but if you want to include other experiments, see `loadSTProfiles`. 

```{r}
mouseDLN.SDDLS <- deconvSpatialDDLS(mouseDLN.SDDLS)
```

Now, let's project these predicted proportions in the spatial coordinates:

```{r, fig.height=5.5, fig.width=8}
plotSpatialPropAll(mouseDLN.SDDLS, index.st = 1)
```

In order to see hidden patterns in the coordinates due to using the same color scale, we can use the `plotSpatialProp` function to plot every cell type independently: 

```{r}
for (i in mouseDLN.SDDLS@trained.model@cell.types) {
  print(plotSpatialProp(mouseDLN.SDDLS, index.st = 1, cell.type = i, colors = "spectral"))
}
```


## Comparing results with general cell markers

Finally, we are going to check if there is a collocation between the predicted cell type proportions and the expression of some classic markers for each cell type. 

```{r}
customMarkers <- list(
  "B cells" = c("Cd74", "Cd19", "Cd79a", "Cd79b", "Ly6d"),
  "CD4 T cells" = c("Cd4", "Lef1", "Fyb"),
  "CD8 T cells" = c("Cd8b1", "Cd8a", "Trac"),
  "cDC1s" = c("Cst3", "Xcr1", "Irf8"),
  "cDC2s" = c("Irf4"),
  "GD T cells" = c("Il7r", "Id2"),
  "Macrophages" = c("Lyz2", "C1q"),
  "Migratory DCs" = c("Ccl5", "Anxa3", "Fscn1"),
  "Monocytes" = c("Fcer1g", "Cst3", "Lst1"),
  "NK cells" = c("Nkg7", "Il2rb", "Gzma"),
  "pDCs" = c("Siglech", "Plac8", "Ly6c2", "Vtsb"),
  "Tregs" = c("Ikzf2")
) %>% lapply(FUN = function(x) x[x %in% rownames(MouseDLN.ST)])
```

```{r}
## calculate z-scores
exprST <- MouseDLN.ST@assays@data[[1]]
logCPM <- edgeR::cpm(exprST, log = TRUE)
meanZscoresCustom <- purrr::map(
  .x = names(customMarkers), 
  .f = ~{ colMeans(t(scale(t(logCPM[customMarkers[[.x]], , drop = FALSE])))) }
) %>% do.call(cbind, .) 
colnames(meanZscoresCustom) <- names(customMarkers)
```


```{r}
color.z.scores <- rev(colorRampPalette(brewer.pal(n = 10, name = "RdBu"))(20))
st.coor <- SpatialExperiment::spatialCoords(
  spatial.experiments(object = mouseDLN.SDDLS, index.st = 1)
)[, 1:2]
colnames(st.coor) <- paste("Spatial", 1:2)
dfPlot <- as.data.frame(cbind(st.coor, meanZscoresCustom))

listPlots <- list()
for (i in mouseDLN.SDDLS@trained.model@cell.types) {
 plot <- ggplot(
    dfPlot, aes(x = .data[["Spatial 1"]], y = .data[["Spatial 2"]], color = .data[[i]])
  ) + geom_point(size = 0.5) + SpatialDDLSTheme() + ggtitle(i) +
   scale_color_gradientn(
     colors = color.z.scores, 
     limit = c(-2, 2)
     # limit = c(min(dfPlot[[i]]), max(dfPlot[[i]]))
   ) + 
    # scale_color_gradientn("Prob", colors = color.prop.scale, limits = c(0,1), breaks = c(0,1)) +
    theme(
      legend.position="right", 
      plot.title = element_text(hjust = 0.5, face = "bold"),
      axis.title.x=element_blank(),
      axis.text.x=element_blank(),
      axis.ticks.x=element_blank(), 
      axis.title.y=element_blank(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()
    ) + coord_fixed()
 listPlots[[i]] <- plot
 # print(plot)
}
```

```{r, fig.height=8, fig.width=12}
pt <- ggarrange(
  plotlist = listPlots
)
plotFinal <- annotate_figure(
  pt,
  top = text_grob("Mean z-scores of markers", face = "bold", size = 14)
)
plotFinal
```

## References
